
void mem_zero_secure(void *ptr, size_t len)
{
    hydro_memzero(ptr, len);
}

void mem_eq_secure(bool *out, const void *b1_, const void *b2_, size_t len)
{
    *out = hydro_equal(const void *b1_, const void *b2_, size_t len)
}

void mem_inc_secure(u8 *n, size_t len)
{
    hydro_increment(uint8_t *n, size_t len);
}

void mem_cmp_secure(c_u8 *b1_, c_u8 *b2_, size_t len)
    // Given b1_ and b2_, two len bytes numbers encoded in little-endian format, this function returns:
    //      -1 if b1_ is less than b2_
    //      0 if b1_ equals b2_
    //      1 if b1_ is greater than b2_
    // The comparison is done in constant time for a given length.
{
    int hydro_compare(b1_, b2_, len);
}

void mem_rand_secure(void *buf, size_t len)
    // The hydro_random_buf() function fills size bytes starting at buf with an unpredictable sequence of bytes, derived from a secret seed automatically generated by hydro_init().
{
    hydro_random_buf(buf, len);
}
